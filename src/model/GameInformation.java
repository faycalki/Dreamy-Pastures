/**
 * Generates the model
 *
 * @author Faycal Kilali, Peter MacAulay
 * @version 0.5
 */

package model;

import model.dreamtiles.DreamTile;

import java.util.ArrayList;

public class GameInformation implements IGameInformation {
    private final int NIGHTMARE_CARD_PLAY_DELAY = 3;
    private final int SHEEP_CARD_PLAY_DELAY = 2;
    private IGameBoard gameBoard;
    private IScoreBoard scoreBoard;
    private ReferenceTile referenceTile;
    //private Phase[] phase;
    private IFirstSheep firstSheep;
    private NightmareReferenceCard referenceCard;
    private IRuleBook rulebook;
    private IRacingPhase racingPhase;
    private IRestingPhase restingPhase;
    private ICardDeck cardDeck;
    private IDreamTileDeck dreamDeck;


    public GameInformation() {

    }

    /**
     * Generates the rest of the model, any remaining model aspects will be generated by the objects generated through this method.
     * @param nightmareChoice the choice of Nightmare for the game. 
     */
    @Override
    public void generateModel(int nightmareChoice) {

        racingPhase = new RacingPhase();
        restingPhase = new RestingPhase();


        dreamDeck = new DreamTileDeck();
        dreamDeck.createDeck();


        this.rulebook = new RuleBook();
        this.referenceTile = new ReferenceTile();
        this.firstSheep = new FirstSheep();
        this.gameBoard = new GameBoard();
        this.scoreBoard = new ScoreBoard();

        referenceCard = new NightmareReferenceCard(nightmareChoice);
        referenceCard.initializeToken(gameBoard);
        racingPhase.setFirstSheep(firstSheep);
        // got to set for resting Phase
        restingPhase.setBoard(gameBoard);
    }

    /**
     * generates the second stage of the model
     */
    public void generateModelStageTwo() {
        IActionable actionable = new Actionable();
        IFence fence = new Fence();
        for (IPlayer player : firstSheep.getTurnSequence()) {
            player.setNightmareReferenceCard(referenceCard);
            player.setActionable(actionable);
            player.getSheepToken().setBoard(gameBoard);
            player.getPillowToken().setBoard(scoreBoard);
            player.getWinkToken().setBoard(scoreBoard);
            player.getSheepToken().setFence(fence);
            player.getPillowToken().setToDefaultPosition();
        }

        referenceTile.setPlayersList(firstSheep.getTurnSequence());
        referenceCard.getNightmareToken().setFence(fence);
        referenceCard.getNightmareToken().setBoard(gameBoard);
        racingPhase.setFence(fence);
        cardDeck = new CardDeck(firstSheep.getTurnSequence(), referenceCard);
        racingPhase.setDeck(cardDeck);

        // place tokens on board, will do so at the start by calling the reset-able object's reset method
        racingPhase.reset(getTurnSequence(), referenceCard, cardDeck);
        fence.setRacingPhase(racingPhase);
        racingPhase.setReferenceTile(referenceTile);
        racingPhase.setNightmareReferenceCard(referenceCard);
        gameBoard.setDreamTileDeck(dreamDeck);

    }


    /**
     * returns the instance of IGameBoard
     * @return IGameBoard
     */
    @Override
    public IGameBoard getGameBoard() {
        return gameBoard;
    }

    /**
     * returns the instance of IScoreBoard
     * @return IScoreBoard
     */
    @Override
    public IScoreBoard getScoreBoard() {
        return scoreBoard;
    }

    /**
     * returns the instance of ReferenceTile
     * @return ReferenceTile
     */
    @Override
    public ReferenceTile getReferenceTile() {
        return referenceTile;
    }

    /**
     * returns the instance of IFirstSheep
     * @return IFirstSheep
     */
    @Override
    public IFirstSheep getFirstSheep() {
        return firstSheep;
    }

    /**
     * returns the instance of NightmareReferenceCard
     * @return NightmarReferenceCard
     */
    @Override
    public NightmareReferenceCard getNightmareReferenceCard() {
        return referenceCard;
    }

    /**
     * returns the instance of IRuleBook
     * @return IRuleBook
     */
    @Override
    public IRuleBook getRuleBook() {
        return rulebook;
    }

    /**
     * returns the instance of IRacingPhase
     * @return IRacingPhase
     */
    @Override
    public IRacingPhase getRacingPhase() {
        return racingPhase;
    }

    /**
     * returns the instance of IRestingPhase
     * @return IRestingPhase
     */
    @Override
    public IRestingPhase getRestingPhase() {
        return restingPhase;

    }

    /**
     * returns the instance of IDreamTileDeck
     * @return IDreamTileDeck
     */
    @Override
    public IDreamTileDeck getDreamTileDeck() {
        return dreamDeck;

    }

    /**
     * returns the instance of ICardDeck
     * @return ICardDeck
     */
    @Override
    public ICardDeck getCardDeck() {
        return cardDeck;
    }

    /**
     * gets the Sheep card deck
     * @return Sheep card deck
     */
    @Override
    public ArrayList<SheepCard> getSheepCardDeck(){
        return getCardDeck().getSheepCardDeck();
    }

    /**
     * gets the Nightmare card deck
     * @return Nightmare card deck
     */
    @Override
    public ArrayList<NightmareCard> getNightmareCardDeck(){
        return getCardDeck().getNightmareCardDeck();
    }

    /**
     * returns the delay for playing a NightmareCard
     * @return int
     */
    @Override
    public int getNightmareCardPlayDelay() {
        return NIGHTMARE_CARD_PLAY_DELAY;
    }

    /**
     * returns the delay for playing a SheepCard
     * @return
     */
    @Override
    public int getSheepCardPlayDelay() {
        return SHEEP_CARD_PLAY_DELAY;
    }

    /**
     * returns current player's hand
     * @return current player's cards in hand
     */
    @Override
    public Card[][] getCurrentHand(){
        return firstSheep.getCurrentHand();
    }

    /**
     * returns the turn sequence
     * @return turn sequence
     */
    public ArrayList<IPlayer> getTurnSequence(){
        return firstSheep.getTurnSequence();
    }

    /**
     * increments current turn
     */
    public void incrementTurn(){
        firstSheep.incrementTurn();
    }

    /**
     * places first DreamTiles at the half and end points of the board
     * returns false to signify that the tiles were placed
     * @return resets the boolean of if the tiles were placed for the next game
     */
    public boolean placeFirstDreamTiles(){
        restingPhase.placeTile(4,dreamDeck.draw());
        restingPhase.placeTile(9,dreamDeck.draw());
        return false;
    }

    /**
     * returns current player
     * @return current player
     */
    public IPlayer getCurrentPlayer(){
        return firstSheep.getCurrentTurn();
    }

    /**
     * returns the number of players who are out
     * @return number of players who are out
     */
    public int getPlayersOut(){
        int outplayers = 0;
        for(IPlayer player : getTurnSequence()){
            if(player.getIsOut()){
                outplayers ++;
            }
        }
        return outplayers;
    }

    /**
     * returns the number of players who called it a night
     * @return number of players who called it a night
     */
    public int getPlayersCalledItANight(){
        int calledItANightPlayers = 0;
        for(IPlayer player : getTurnSequence()){
            if(player.getCalledItANight()){
                calledItANightPlayers ++;
            }
        }
        return calledItANightPlayers;
    }

    /**
     * determines if the phase is over based on if there are any players playing
     */
    @Override
    public boolean checkRacingPhaseOver(){
        if(getPlayersOut() + getPlayersCalledItANight() == getTurnSequence().size()){
            return true;
        }
        return false;
    }

    /**
     * returns the state of the racing phase
     * @return RacingPhase activity state
     */
    @Override
    public boolean isRacingPhaseOver(){
        return racingPhase.isPhaseOver();
    }

    /**
     * ends racing phase
     */
    public void endRacingPhase(){
        racingPhase.endPhase();
    }

    /**
     * gets valid DreamTile indexes to place DreamTiles on
     * @return valid indexes to place DreamTiles on
     */
    public ArrayList<Integer> occupiedDreamTileSpots(){
        return restingPhase.occupiedDreamTileSpots();
    }

    /**
     * gets DreamTile Array from GameBoard
     * @return DreamTile array
     */
    public DreamTile[] getDreamTileArray(){
        return gameBoard.getDreamTileArray();
    }



    /**
     * draws a card from the deck for a given player
     */
    public SheepCard drawSheepCard(IPlayer currentPlayer) {
        SheepCard card = cardDeck.drawSheepCard();
        currentPlayer.addCard(card);
        return card;
    }

    public NightmareCard drawNightmareCard(IPlayer currentPlayer){
        NightmareCard card = cardDeck.drawNightmareCard();
        currentPlayer.addCard(card);
        return card;
    }

    /**
     * finds the index of a given card in the current player's hand
     * @param card attempting to find
     * @return index of given card in current players hand
     */
    public int findCardInHand(Card card){
        int cardNum = 0;
        for (int i = 0; i < getCurrentHand().length; i++) {
            for (int j = 0; j < getCurrentHand()[i].length; j++) {
                //if the card is found
                if (getCurrentHand()[i][j] != null && getCurrentHand()[i][j].equals(card)) {
                    //cardNum is set to the index of the card
                    cardNum = i + 1;
                }
            }
        }
        if(cardNum == 0){
            throw new IllegalArgumentException("Card not found");
        }
        return cardNum;
    }

    public void createCardDeck(){
        cardDeck.createDeck(getTurnSequence(), referenceCard);
    }

    /**
     * returns the DreamTile market from DreamTileDeck
     * @return DreamTile[]
     */
    public DreamTile[] getMarket(){
        return dreamDeck.revealMarket();
    }



}
